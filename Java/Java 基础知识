Java 基础知识

#Java 面向对象的三个特征？
	继承：子类继承父类的特征和行为，使得字类对象(实例)具有父类的实例域和方法，或字类从父类继承方法，使得字类具有父类相同的行为。是Java 面向对象编程的一块基石。
		特点：
			1.子类拥有父类非private的属性、方法；
			2.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；
			3.子类可以用自己的方式实现父类的方法；
			4.Java的继承是单继承，但是可以多重继承。
			5.提高了类之间的耦合性（缺点：耦合度高就会造成代码这件的联系比较紧密，代码独立性越差）

	封装：将类中的属性和实现细节包装起来，之对外提供get()和set() 
		优点：
			1.良好的封装能较少耦合；
			2.类内部的结构可以自由的修改；
			3.可以对成员变量进行更精确的控制；
			4.隐藏信息，实现细节。

	多态：同一个行为具有不同表现形式或形态的能力（对象多种表现形式的体现）。多态是同一个接口，使用不同的实例而执行不同的操作。
		优点：
			1.消除类型之间的耦合关系；
			2.可替换性；
			3.可扩充性；
			4.接口性；
			5.灵活性
			6.简化性。
		多态存在的三个必要条件：
			1.继承;
			2.重写;
			3.父类引用指向子类对象：Parent p = new Child().

#重写(Override) 和重载(Overload)的区别？
	
	重写(Override)：子类对父类的允许访问的方式实现过程进行重新编写，返回值和形参都不能改变，子类可以根据需要，定义自己的行为。

	重载(Overload)：是在一个类里面，方法名字必须相同，而参数不同，返回类型可以相同也可以不同。

	总结：方法的重写(Override)和重载(Overload) 是Java 多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体变现形式。

#抽象类(abstract)和接口(Interface)的区别？
	抽象类：
		1.抽象类不能被实例化，只有抽象类的子类可以创建对象；
		2.抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；
		3.抽象类中的抽象方法只是声明，没有方法体，需要子类继承后实现方法的具体功能；
		4.构造方法、类方法（用static修饰的方法）不能声明为抽象方法；
		5.抽象类的子类必须实现抽象类的抽象方法，除非该子类也是抽象类。	

	接口(Interface)：
		1.接口不能被实例化；
		2.接口中的每一个方法也是隐式抽象的，接口中的方法会被隐士的指定为 public   abstract(只能是 public abstract,其他修饰符都会报错)；
		3.接口中可以包含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是public）
		4.接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

	抽象类和接口区别：
		1.抽象类中的方法可以有方法体，但是接口中的方法不行；
		2.抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；
		3.接口中不能包含有静态代码块以及静态方法，而抽象类是可以有静态代码块和静态方法。
		4.一个类只能继承一个抽象类，而一个类却可以实现多个接口。

#静态内部类(Static class)与非静态内部类(non static class)的区别？
	1.静态内部类不需要有指向外部类的引用就可以调用，非静态内部类需要持有对外部类的引用才可以调用；
	2.非静态内部类只能访问外部类的静态成员和静态方法，非静态内部类可以访问外部类的静态成员和静态方法；
	3.非静态内部类不能离开外部类的引用而创建，非静态内部类可以访问外部类的成员和方法。
#Java 集合 List、Set、Map的区别？
	

	Set:元素是无序的，且不可以重复（存如和取出的顺序不一定一致），线程不同步。
		1.HashSet:底层是哈希表数据结构，根据 hashCode 和 equals 方法来确定元素的唯一性；
		2.TreeSet：可以对Set集合中的元素进行排序（自然循序），底层的数据结构是二叉树，也可以自己写个类实现Comparable 或者 Comparator 接口，定义自己的比较器，将其作为参数传递给 TreeSet 的构造函数。

	Map:集合是存储键值对，一对一对往里存入，而且要保证键的唯一性。
		1.HashTable:底层是哈希表数据结构，不可以存如null键和null值，该集合线程是同步的，效率比较低;
		2.HashMap:底层是哈希表数据结构，可以存如null键和null值，线程不同步，效率较高，代替了HashTable;
		3.TreeMap:底层是二叉树数据结构，线程不同步，可以用于对Map 集合中的键进行排序。

#Collection 和 Collections 的却别？
	1.Collection:它是一个接口，是Set、List等集合的父接口；
	2.Collections：它是一个工具类，提供了一系列的静态方法来辅助集合的操作，这些方法包含了对集合的搜素、排序、线程安全化等等。

#Map、List、Set、Queue、Stack的特点与用法？
	Map:集合是存储键值对，一对一对往里存入，而且要保证键的唯一性。
			1.HashTable:底层是哈希表数据结构，不可以存如null键和null值，该集合线程是同步的，效率比较低;
			2.HashMap:底层是哈希表数据结构，可以存如null键和null值，线程不同步，效率较高，代替了HashTable;
			3.TreeMap:底层是二叉树数据结构，线程不同步，可以用于对Map 集合中的键进行排序。
	List:元素是有序的，元素可以重复，每个元素都有自己的角标(索引)。
		1.ArrayList:底层的数据结构是数组结构，特点是：查询很快，增删慢，线程不同步；
		2.LinkedList:底层用的是链表数据结构，特点是：增删快，查询慢；
		3.Vector:底层是数组数据结构，线程同步，方法被synchronized修饰，被ArrayList代替，现在用的只有他的枚举。
	Set:元素是无序的，且不可以重复（存如和取出的顺序不一定一致），线程不同步。
		1.HashSet:底层是哈希表数据结构，根据 hashCode 和 equals 方法来确定元素的唯一性；
		2.TreeSet：可以对Set集合中的元素进行排序（自然循序），底层的数据结构是二叉树，也可以自己写个类实现Comparable 或者 Comparator 接口，定义自己的比较器，将其作为参数传递给 TreeSet 的构造函数。
	Stack:继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。
	Queue:提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。

